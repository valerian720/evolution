/* Требования к функциональности компьютерной программы
- Возможность задания топологии сети с указанием ее размерности и пропускной способностью каналов.
- Настройки работы генетического алгоритма: размер популяции, количество cпоколений, варианты кроссовера, вероятность мутации и др.
- Указание исходных данных (компьютер-отправитель и компьютер-получатель) и автоматическое заполнение исходных данные топологии сети.
- Два режима работы:
    - пошаговый - на экране должны отображаться все представители (хромосомы) одного поколения до и после применения каждого оператора (скрещивания, селекции, редукции и мутации).
    - циклический - на экране должны отражаться только агрегированные данные по каждому поколению и итоговый набор хромосом.
- На одной из экранных форм должны быть указаны ФИО и e-mail автора приложения, ссылка на учебный курс и год разработки. Эти данные должны быть продублированы в тексте программы (каждого программного модуля).
- Дополнительно необходимо реализовать возможность динамического изменения исходных данных (матрицы связанности графа) во время пошагового режима работы алгоритма.
*/

/* параметры сети:
* - топология
* - размерность
* - пропускная способность каналов
*/

/* настройка генетического алгоритма:
* - размер популяции
* - количество поколений
* - варианты кросовера
* - вероятность мутации
* - др.
*/

/* режимы работы:
*  - пошаговый
*  - циклический
*/

/* 
* 
* 
*/

/* описание структуры ядра
* Net (содержит гиперпараметры)
*  - 
* NetContainer ( содержит полносвязный неориентированный граф, методы для управления им, методы для экспорта / импорта )
*  - 
* Genetic (содержит гиперпараметры)
*  - 
* GeneticController (содержит и управляет списком особей (популяция), )
* - 
* Individual (содержит набор хромосом (генотип))
*  - public GetFit2TaskIndividual()
*  - 
* Chromosome (содержит последовательность генов (локус))
*  - List<Gene> lokus
*  - private GenerateLokus()
*  - public GetFit2TaskLokus()
*  - private Mutate(MutationType type)
* 
* MutationType (содержит обработку мутаций хромосомы (локус))
*  - virtual static mutate() // ?
* 
* FullRandomMutation:MutationType // выбор рандомного значения по словарю
*  - GeneValue[] possibleOutcome;
*  - Random rnd = new Random();
*  - override GetFit2TaskGene()
* 
* GeneValue (содержит значение гена (аллель))
*  - virtual GetFit2TaskGene()
* NodeValue : GeneValue (содержит реализацию свойства гена)
*  - override GetFit2TaskGene()
*  - private int[] data
*/

/* описание структуры сцены
* есть корень в котором находится 2 ноды
* - первая нода отвечае за интерфейс (открытие/закрытие на esk)
*      - первая поднода отвечает за ввод/отображение данных сети
*           - цифровое поле для ввода количества компьютеров
*           - json поле в котором находится пресдтавление связей пк (можно оттуда копировать данные так и вставлять)
*           - дропдаун меню для выбора пресета топологии сети
*               - полносвязанная (по умолчанию) (веса генерятся рандомно)
*               - звезда (выбирается в центре концентратор и все не связанные с ним веса становятся максимальные) (мб даже дать выбор опетатору)
*               - кольцо (веса связей в центре сети становятся максимальные)
*           - таблица с прокруткой
*               - как x и как y отображается список ПК
*               - на пересечении можно ввести вес (изначально генерится автоматом, и при изменении количества ПК перерегенится)
*               
*      - вторая поднода отвечает за отображение и настройку генетического алгоритма
*          - цифровое поле ввода размера популяции
*          - цифровое поле ввода количества поколений
*          - цифровое поле ввода вероятности мутаций
*          - 
*      -  третья поднода отвечает за отображение графиков (ака статистика)
*           - 
*          
*          
* - вторая нода отвечает за само размещение сети (генерация и апдейт идет из скрипта)
*       - первая поднона представляет из себя переключатьль между [пауза, пошаговый, циклический] режимы работы (по умолчанию стоит пауза)
*       - вторая поднода отвечает за размещение компьтеров
*           - отдельный компьютер содержит:
*            - спрайт компьютера
*            - текст, номер компьютера
*            - текст задержка пакета при проходе его через пк (?)
*       - третья нода отвечает за размещение линий
*          - отдельная линия:
*              - объект линии (мб толщина линии обратно пропорциональна ее весу ака чем меньше тем больше)
*              - текст, вес линии
*/

/* задача - 
* 
* 
*/

/**
* Рекомендации по реализации
Рекомендуется в качестве хромосомы выбрать постоянную по длине последовательность вершин или дуг.
Длину можно выбрать произвольную, но не меньше, чем N–2, где N – общее количество компьютеров в сети.

Для упрощения расчетов граф сети лучше сделать полносвязанным (каждая пара вершина имеет связь).
Для обозначения отсутствия связи (соединения) нужно выбрать очень большое значение веса дуги,
а для петли (дуги, соединяющей вершину с самой собой) – значение веса равное 0. 
Такой подход позволит искать пути, которые по длине меньше, чем размер хромосомы.

Если в качестве хромосомы используется последовательность вершин (узлов сети),
то необходимо либо исключить первую и последнюю вершину (т.е. задавать только вершины пути),
либо не изменять их в результате применения генетических операторов.
Можно также реализовать направленный оператор мутации, который всегда устанавливает заданные на входе вершины,
соответствующие компьютеру-отправителю и компьютеру-получателю.

Допускается использование в качестве генов букв или чисел в десятеричной системе.
Если используется битовая строка, то для удобства лучше выбрать количество серверов равное 2n (16, 32, 64 и т.д.).
Это позволит избежать формирования в результате скрещивания и мутации несуществующих номеров вершин (узлов, серверов).

Если в исходной популяции не представлены все возможные вершины (гены), 
то они могут появиться только в результате мутации, 
поэтому рекомендуется в начальной выборке представить весь генофонд.

Если выбранный алгоритм скрещивания меняет только правую (левую) часть хромосомы или только 4 гена из 10, 
то его эффективность невысока (т.к. часть генов не будет изменяться), и единственная надежда - на алгоритм мутации и удачные исходные данные.

Стоит также помнить, что повторяющиеся (идентичные) хромосомы лучше исключать (удалять, мутировать) на начальных этапах. 
Если размер популяции фиксированный, то это может быть неизбежным при сходимости алгоритма и вырождения популяции.

* 
* 
*/